<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>flexPTP: Porting and configuration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="large-top-height.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="flexPTP_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">flexPTP<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">An IEEE 1588 PTP implementation designed for microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('porting.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Porting and configuration </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In the <a class="el" href="porting.html#port-config-port">Porting</a> section a guide is presented to help porting flexPTP to a new platform. In the <a class="el" href="porting.html#port-config-configuration">Configuration</a> part basic and initial settings are listed.</p>
<h1><a class="anchor" id="port-config-port"></a>
Porting</h1>
<p>We have included numerous examples into the basic flexPTP package with the intent to clarify purpose and structure of each porting file. The flexPTP accesses the target system using the following modules:</p>
<ul>
<li>a <code>flexptp_options.h</code> <b>configuration file</b>, that defines settings for hardware clock operation, provides handles to the servo, connects flexPTP to the standard output and passes common includes to all flexPTP modules.</li>
<li><b>Network Stack Driver</b> that outsources the message transmission and reception to and from the network. It acts like a glue code between the flexPTP and the network stack.</li>
<li>a (simple) <b>hardware clock driver</b>, through which flexPTP can set or tune the hardware clock and query time.</li>
</ul>
<p>In the sections below you'll see samples for all three configuration module types.</p>
<h2><a class="anchor" id="autotoc_md58"></a>
Port option file</h2>
<p>Each project that includes flexPTP must provide a <code>flexptp_options.h</code> header file. This file has the purpose to tell flexPTP the basic hardware features (e.g. oscillator frequency), and to define bindings to hardware clock and servo management routines.</p>
<p>Our experience with embedded development shows that a newcomer might run into difficulties on creating a port to a software to be learned. We recommend you to open an example <code>flexptp_options_XXX.h</code> file from the <code>port/example_options</code> location before reading the following. Taking a quick look into a pre-made configuration file might make the interpretation of the section below much easier.</p>
<p>The assembling of a configuration file can be broken down into the following major steps:</p>
<ol type="1">
<li>Choose an <b>OS interface</b>:<ul>
<li>define the <code>FLEXPTP_CMSIS_OS2</code> macro to use the <a href="https://arm-software.github.io/CMSIS_5/RTOS2/html/index.html">CMSIS OS2</a> bindings <b>OR</b></li>
<li>define the <code>FLEXPTP_FREERTOS</code> macro to let the library call the <a href="https://www.freertos.org/">FreeRTOS</a> API directly OS headers must be available to the library (e.g. cmsis_os2.h, FreeRTOS.h, etc.).</li>
</ul>
</li>
<li>Define <b>printing routines or macros</b>:<ul>
<li><code>MSG(...)</code>: a basic formatted printing function that mimics <code>printf()</code> functionality (called with <code>printf()</code>-fashioned parameters). flexPTP uses the following formatting marks: <code>%d</code>, <code>%i</code>, <code>%u</code>, <code>%lu</code>, <code>%f</code>, <code>%x</code>, <code>%X</code>, <code>%s</code>, <code>%c</code>, <code>%%</code>.</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a916dcd9d22af4bd2d5c7c90958bf011a">CLILOG(en,...)</a></code>: a maskable printing function: if <code>en</code> is <code>true</code>, it behaves like <code>MSG(...)</code></li>
<li><code>SPRINTF(str,n,...)</code>: a basic <code>snprintf()</code> implementation, that supports at least the same set of formatting marks as <code>MSG(...)</code> does</li>
</ul>
</li>
<li>Define hardware <b>clock management functions</b>: Two different clock management interface are supported, the ADDEND-based and the HLT interface. More on this in <a class="el" href="porting.html#hardware-clock-driver">Hardware Clock Driver</a>.<ul>
<li><em>ADDEND interface</em><ul>
<li><b>define the <code>PTP_ADDEND_INTERFACE</code></b> macro to select this interface</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a45ea2e992dddae826985c1cfc4b9c8db">PTP_HW_INIT(increment, addend)</a></code>: a method that initializes the hardware clock. <code>increment</code>: clock increment, <code>addend</code>: initial frequency tuning</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a0b6a510e0ed2770e0e9e6b0b96ab1f5c">PTP_SET_CLOCK(s, ns)</a></code>: a method that sets the hardware clock. <code>s</code>: seconds part of the UNIX time, <code>ns</code>: nanoseconds of the UNIX time</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a342eded57d8df50e4ec8697696b3f1ad">PTP_SET_ADDEND(addend)</a></code>: a method that sets the hardware clock frequency tuning word. <code>addend</code>: 32-bit tuning value (0x00000000..0xFFFFFFFF)</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#acf5d43bb87550622768a5fe6a210402d">PTP_HW_GET_TIME(pt)</a></code>: a method that fetches the time right from the hardware clock. <code>pt</code>: time of type <code><a class="el" href="struct_timestamp_i.html" title="Timestamp (signed)">TimestampI</a> *</code>; time is stored to <code>*pt</code></li>
<li><code>PTP_MAIN_OSCILLATOR_FREQ_HZ</code>: clock frequency that drives the hardware clock in Hz</li>
<li><code>PTP_INCREMENT_NSEC</code>: amount of time the clock gets incremented each tick expressed in nanoseconds</li>
</ul>
</li>
<li><em>HLT interface</em><ul>
<li><b>define the <code>PTP_HLT_INTERFACE</code></b> macro to select this interface</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a45ea2e992dddae826985c1cfc4b9c8db">PTP_HW_INIT()</a></code>: a method that initializes the hardware clock.</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a0b6a510e0ed2770e0e9e6b0b96ab1f5c">PTP_SET_CLOCK(s, ns)</a></code>: a method that sets the hardware clock. <code>s</code>: seconds part of the UNIX time, <code>ns</code>: nanoseconds of the UNIX time</li>
<li><code><a class="el" href="flexptp__options__mk64f_8h.html#a25bf36c86ef05d1102b5cb42bb39a47b">PTP_SET_TUNING(tuning)</a></code>: a method that sets the hardware clock tuning. <code>tuning</code>: tuning in PPB</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#acf5d43bb87550622768a5fe6a210402d">PTP_HW_GET_TIME(pt)</a></code>: a method that fetches the time right from the hardware clock. <code>pt</code>: time of type <code><a class="el" href="struct_timestamp_i.html" title="Timestamp (signed)">TimestampI</a> *</code>; time is stored to <code>*pt</code></li>
</ul>
</li>
</ul>
</li>
<li>Define <b>servo management functions</b>:<ul>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#adf6e86bdb39695261a826be45ee06001">PTP_SERVO_INIT()</a></code>: a function that initializes the controller algorithm</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a61bf41647b76c270fe5bb7079eada447">PTP_SERVO_DEINIT()</a></code>: a function that de-initializes the controller algorithm</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a9667a238d1a36cd467bbfd3eb691ec11">PTP_SERVO_RESET()</a></code>: a function that resets the controller algorithm</li>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#af05581fcddec191de3f30b4a373c5a92">PTP_SERVO_RUN(d, pscd)</a></code>: a function that invokes the controller and returns with a tuning value in PPB. <code>d</code>: time error in nanoseconds, <code>pscd</code>: pointer to synchronization cycle auxiliary context data of type <code><a class="el" href="struct_ptp_servo_aux_input.html" title="Data to perform a full synchronization.">PtpServoAuxInput</a> *</code>. (refer to: <a class="el" href="servo.html">Clock servo</a>)</li>
</ul>
</li>
<li><em>Optionally</em> define a function that registers <b>CLI commands</b>:<ul>
<li><code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a8f8a3ba07b96be3784ed3e774b955427">CLI_REG_CMD(cmd_hintline,n_cmd,n_min_arg,cb)</a></code>: for parameter meanings and types refer to <a class="el" href="cli__cmds_8c.html">cli_cmds.c</a></li>
</ul>
</li>
<li><em>Optionally</em> define a function for <b>loading retained options</b>:<ul>
<li><code><a class="el" href="flexptp__options__stm32f407__etherlib_8h.html#a5c9b2fe63ca003636c787f4eefa5416c">PTP_CONFIG_PTR()</a></code>: a macro that evaluates to a <code>const void *</code> pointer to the area where the flexPTP config was stored previously. flexPTP expects to find a populated <a class="el" href="struct_ptp_config.html" title="Global storable-loadable configuration.">PtpConfig</a> on address returned by <code><a class="el" href="flexptp__options__stm32f407__etherlib_8h.html#a5c9b2fe63ca003636c787f4eefa5416c">PTP_CONFIG_PTR()</a></code>, that was previously generated by <code><a class="el" href="config_8c.html#a84868766e7435c8056768a758bed6137">ptp_store_config()</a></code>.</li>
</ul>
</li>
<li><em>Optionally</em> define a function for handling flexPTP's <b>user events</b> (this can be done during runtime as well):<ul>
<li><code>PTP_USER_EVENT_CALLBACK</code>: a function pointer of the PtpUserEventCallback type</li>
</ul>
</li>
<li><em>Optionally</em> enable <b>Master operation mode</b>:<ul>
<li>set <code>PTP_ENABLE_MASTER_OPERATION</code> to <code>1</code></li>
<li><em>Optionally</em> set (initial) PTP master capabilities, see <a class="el" href="porting.html#port-config-master">Master configuration</a></li>
</ul>
</li>
</ol>
<p>We emphasize, that many examples can be found on configuration files in the <code>port/example_options</code> directory.</p>
<p>Throughout the assembling of a new the options file you might find that the Ethernet driver, that came along the target platform lacks routines handling PTP functionality. In that case you it's your duty to extend the driver with the proper features. Many examples on such extensions can be found in the <code>port/example_ports</code> directory.</p>
<h3><a class="anchor" id="autotoc_md59"></a>
Example option files</h3>
<p><a class="el" href="flexptp__options__stm32f407__etherlib_8h.html">flexptp_options_stm32f407_etherlib.h</a>, <a class="el" href="flexptp__options__stm32h743__etherlib_8h.html">flexptp_options_stm32h743_etherlib.h</a>, <a class="el" href="flexptp__options__stm32h743_8h.html">flexptp_options_stm32h743.h</a>, <a class="el" href="flexptp__options__tm4c1294_8h.html">flexptp_options_tm4c1294.h</a>, <a class="el" href="flexptp__options__mk64f_8h.html">flexptp_options_mk64f.h</a></p>
<h2><a class="anchor" id="network-stack-driver"></a>
Network Stack Driver (NSD)</h2>
<p>The flexPTP library expects (only!) the below message transception related functions given. These are the functions, that are declared in <a class="el" href="network__stack__driver_8h.html" title="This file is a header for the employed Network Stack Driver (NSD). A NSD must define ALL four functio...">network_stack_driver.h</a>. During the porting work, these functions must be implemennted.</p>
<ul>
<li><code>void <a class="el" href="network__stack__driver_8h.html#a448d70ee83a66f7dd5f5e602c7f41b8d">ptp_nsd_init(PtpTransportType tp, PtpDelayMechanism dm)</a></code>: This function initializes (opens and closes) the network connections based on the profile settings passed in the <code>tp</code> and <code>dm</code> parameters. <code>tp</code> and <code>dm</code> can take on any value from <code>PtpTransportType</code> and <code>PtpDelayMechanism</code>, respectively. Passing <code>-1</code> in either parameter signals that the flexPTP wants the network layer to close all connections. In other words, by passing <code>-1</code> the flexPTP does not defined a valid profile. It is expected that this function gets called multiple times. On subsequent calls, the function first informs the network that we are leaving the IGMP-group of the profile we abandon and closes connection associated with the profile we are leaving. Then, it takes on the new profile, opens the new connection and joins the new IGMP-groups. Joining and leaving of the IGMP-groups is performed by invoking the <code><a class="el" href="network__stack__driver_8h.html#a403275d7e5b31f6714a93ebd28d1c2e4">ptp_nsd_igmp_join_leave()</a></code> method.</li>
<li><code>void <a class="el" href="network__stack__driver_8h.html#a06c3b6dbcec5f68576cd1a48bf8755b2">ptp_nsd_transmit_msg(RawPtpMessage *pMsg)</a></code>: The flexPTP engine calls this function to dispatch a PTP message. The NSD can safely anticipate that fields of the message passed from the PTP engine carry fields reflecting the profile that was set by the latest <code><a class="el" href="network__stack__driver_8h.html#a448d70ee83a66f7dd5f5e602c7f41b8d">ptp_nsd_init()</a></code> call. The function must only fetch the PTP message class from the message passed to determine through which connection it has to be sent.</li>
<li><code>void <a class="el" href="network__stack__driver_8h.html#a403275d7e5b31f6714a93ebd28d1c2e4">ptp_nsd_igmp_join_leave(bool join)</a></code>: The flexPTP engine might intend to inform the network about the joining or leaving of the IGMP-group associated with the operating profile (for example upon link recovery). Besides, <code><a class="el" href="network__stack__driver_8h.html#a448d70ee83a66f7dd5f5e602c7f41b8d">ptp_nsd_init()</a></code> references this function as well.</li>
<li><code>void <a class="el" href="network__stack__driver_8h.html#a8084e66715ef332fa46c677421f6b20f">ptp_nsd_get_interface_address(uint8_t * hwa)</a></code>: This function returns with the hardware address of the associated Ethernet interface. Parameter <code>hwa</code> is expected to be able to hold (at least) 6-bytes (the size of an Ethernet Hardware Address).</li>
</ul>
<p>Finally, it's also the job of the NSD module to make the received messages available to the flexPTP core. This is done by calling the <code><a class="el" href="task__ptp_8c.html#a1409be7128c102f50cc590ec0aa817e0">ptp_receive_enqueue()</a></code> function with the proper parameters: data, size and ingress timestamp split into seconds and nanoseconds field.</p>
<p>Inherently, the fetching and exchanging of the ingress and egress timestamps with the flexPTP core fall also in the scope of the NSD module.</p>
<h3><a class="anchor" id="autotoc_md60"></a>
NSD examples</h3>
<p><a class="el" href="nsd__lwip_8c.html">nsd_lwip.c</a>, <a class="el" href="nsd__etherlib_8c.html">nsd_etherlib.c</a> : Sample NSD implementations for lwIP and EtherLib network stacks.</p>
<h2><a class="anchor" id="hardware-clock-driver"></a>
Hardware Clock Driver</h2>
<p>The library supports two different, mutually exclusive clock management interfaces: the old-style <b>ADDEND-based</b> tuning interface and the newly introduced <b>High-Level Tuning (HLT)</b> interface. The user should implement the one better matched to the underlying hardware.</p>
<h3><a class="anchor" id="autotoc_md61"></a>
ADDEND-interface</h3>
<div class="image">
<img src="tuneable_hardware_clock.png" alt=""/>
<div class="caption">
General structure of a PTP hardware clock with distinguished high precision frequency divider and counter</div></div>
    <p>This interface assumes the above hardware clock model. In the majority of the microcontrollers with PTP support the structure of the PTP hardware clock follows this scheme.</p>
<p>Such hardware clocks can be tuned by altering a so called frequency tuning code word. The actual tuning value, a code word is an addend of a high-precision frequency divider in the clock's core. The code word is directly proportional with the output frequency. That's why we decided to represent 0 frequency with a zero and the maximum frequency with a <code>0xFFFFFFFF</code> ( \(2^{32}-1\)) 32 bits code word. The former phrase in the form of a function:</p>
<p class="formulaDsp">
\[
    f_\text{clock} = f_\text{osc} \frac{\texttt{CODE WORD}}{2^{32}}
\]
</p>
<p>Hardware clocks keep time by increasing their stored time value with an <code>increment</code> in every clock cycle (i.e. clock cycle of the divided clock). The <code>increment</code> is usually constant and is set during the initialization. (It is usually expressed in nanoseconds.)</p>
<p><em>Addend</em> and <em>increment</em> are the two basic idea that are supported by all such hardware clocks. The hardware clock driver must be able to control at least these two fields. By nature, clock drivers implementing the ADDEND-interface are low-level drivers.</p>
<p>More general, the hardware clock driver must provide solutions for:</p><ul>
<li>initializing the hardware (<code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a45ea2e992dddae826985c1cfc4b9c8db">PTP_HW_INIT(increment, addend)</a></code>),</li>
<li>setting the clock's time (<code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a0b6a510e0ed2770e0e9e6b0b96ab1f5c">PTP_SET_CLOCK(s, ns)</a></code>),</li>
<li>tuning the clock's frequency using a code word (<code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a342eded57d8df50e4ec8697696b3f1ad">PTP_SET_ADDEND(addend)</a></code>),</li>
<li>obtaining the time from the clock (<code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#acf5d43bb87550622768a5fe6a210402d">PTP_HW_GET_TIME(pt)</a></code>).</li>
</ul>
<p>To maintain backward-compatibility this interface is auto-selected if no interface selection macro was defined. The best practice is to define the <code>PTP_ADDEND_INTERFACE</code> macro to explicitly select this interface.</p>
<p>Additionally, the frequency of the PTP clock input and the increment must also be defined: <code>PTP_MAIN_OSCILLATOR_FREQ_HZ</code>, <code>PTP_INCREMENT_NSEC</code></p>
<p>Usually the hardware clock driver also implements further miscellaneous functionality, like the controlling of the PPS output signal.</p>
<h4><a class="anchor" id="autotoc_md62"></a>
Example option files</h4>
<p><a class="el" href="flexptp__options__stm32f407__etherlib_8h.html">flexptp_options_stm32f407_etherlib.h</a>, <a class="el" href="flexptp__options__stm32h743__etherlib_8h.html">flexptp_options_stm32h743_etherlib.h</a>, <a class="el" href="flexptp__options__stm32h743_8h.html">flexptp_options_stm32h743.h</a>, <a class="el" href="flexptp__options__tm4c1294_8h.html">flexptp_options_tm4c1294.h</a></p>
<h4><a class="anchor" id="autotoc_md63"></a>
Example Hardware Clock Driver files</h4>
<p><a class="el" href="ptp__port__stm32f407__etherlib_8c.html">ptp_port_stm32f407_etherlib.c</a>, <a class="el" href="ptp__port__stm32f407__lwip_8c.html">ptp_port_stm32f407_lwip.c</a>, <a class="el" href="ptp__port__stm32h743__etherlib_8c.html">ptp_port_stm32h743_etherlib.c</a>, <a class="el" href="ptp__port__stm32h743__lwip_8c.html">ptp_port_stm32h743_lwip.c</a>, <a class="el" href="ptp__port__tiva__tm4c1294_8c.html">ptp_port_tiva_tm4c1294.c</a></p>
<h3><a class="anchor" id="autotoc_md64"></a>
High-Level Tuning (HLT) interface</h3>
<p>This interface enables flexPTP to operate hardware clocks regardless of the clock's inner structure considering the clock as a black-box device. This interface is provided to extend flexPTP support to devices with hardware clocks differing from the formerly introduced one.</p>
<p>The interface consists of the following few methods:</p><ul>
<li>hardware initialization (<code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a45ea2e992dddae826985c1cfc4b9c8db">PTP_HW_INIT()</a></code>),</li>
<li>clock setting (<code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#a0b6a510e0ed2770e0e9e6b0b96ab1f5c">PTP_SET_CLOCK(s, ns)</a></code>),</li>
<li>clock tuning in PPB (<code><a class="el" href="flexptp__options__mk64f_8h.html#a25bf36c86ef05d1102b5cb42bb39a47b">PTP_SET_TUNING(tuning)</a></code>),</li>
<li>querying the clock (<code><a class="el" href="flexptp__options__ch32f207__etherlib_8h.html#acf5d43bb87550622768a5fe6a210402d">PTP_HW_GET_TIME(pt)</a></code>).</li>
</ul>
<p>To select this interface, defined the <code>PTP_HLT_INTERFACE</code> macro.</p>
<p>Usually the hardware clock driver also implements further miscellaneous functionality, like the controlling of the PPS output signal.</p>
<h4><a class="anchor" id="autotoc_md65"></a>
Example option files</h4>
<p><a class="el" href="flexptp__options__mk64f_8h.html">flexptp_options_mk64f.h</a></p>
<h4><a class="anchor" id="autotoc_md66"></a>
Example Hardware Clock Driver files</h4>
<p><a class="el" href="ptp__port__mk64f__lwip_8c.html">ptp_port_mk64f_lwip.c</a></p>
<h1><a class="anchor" id="port-config-configuration"></a>
Configuration</h1>
<h2><a class="anchor" id="autotoc_md67"></a>
Initial configuration</h2>
<p>List of definitions, part of the initial configuration, with default values. Default values are used if macros are not defined in <code>flexptp_options.h</code>.</p>
<h3><a class="anchor" id="port-config-opmode-params"></a>
Operation mode parameters</h3>
<p>Macros controlling basic internal operation.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PTP_HEARTBEAT_TICKRATE_MS</code>   </td><td class="markdownTableBodyNone">125   </td><td class="markdownTableBodyNone">Internal core scheduler period (ms)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PTP_ACCURACY_LIMIT_NS</code>   </td><td class="markdownTableBodyNone">100   </td><td class="markdownTableBodyNone">Threshold of the <code>LOCKED</code> state (ns)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PTP_DEFAULT_SERVO_OFFSET_NS</code>   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Initial servo offset (ns) (can be changed in runtime)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PTP_DEFAULT_COARSE_TRIGGER_NS</code>   </td><td class="markdownTableBodyNone">20000000   </td><td class="markdownTableBodyNone">Coarse correction kick-in threshold (ns) (can be changed in runtime)   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md68"></a>
PTP definitions</h3>
<h4><a class="anchor" id="autotoc_md69"></a>
Common</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PTP_PORT_ID</code>   </td><td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">ID of the Ethernet interface assigned to flexPTP   </td></tr>
</table>
<h4><a class="anchor" id="port-config-BMCA"></a>
BMCA</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PTP_BMCA_LISTENING_TIMEOUT_MS</code>   </td><td class="markdownTableBodyNone">3000   </td><td class="markdownTableBodyNone">Timeout of the <code>LISTENING</code> BMCA-state (ms)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PTP_MASTER_QUALIFICATION_TIMEOUT</code>   </td><td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">Timeout of <code>PRE_MASTER</code> state (Announce-intervals)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PTP_ANNOUNCE_RECEIPT_TIMEOUT</code>   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Number of tolerated consecutive lost Announce messages   </td></tr>
</table>
<h4><a class="anchor" id="port-config-master"></a>
Master</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PTP_ENABLE_MASTER_OPERATION</code>   </td><td class="markdownTableBodyNone">0 (disabled)   </td><td class="markdownTableBodyNone">Enable/disable master operation (once disabled here CANNOT be enabled in runtime)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PTP_FALLBACK_UTC_OFFSET</code>   </td><td class="markdownTableBodyNone">37   </td><td class="markdownTableBodyNone">Initial UTC offset caused by the accumulated leap seconds (s)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PTP_PDELAY_SLAVE_QUALIFICATION</code>   </td><td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Number of consecutive PDelReq-PDelResp iterations after the SLAVE is considered stable    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PTP_PDELAY_DROPOUT</code>   </td><td class="markdownTableBodyNone"><code>PTP_PDELAY_SLAVE_QUALIFICATION</code>   </td><td class="markdownTableBodyNone">Maximum number of failed PDelReq-PDelResp cycles before the MASTER drops the SLAVE   </td></tr>
</table>
<h4><a class="anchor" id="port-config-clock-dataset"></a>
Clock dataset</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PTP_CLOCK_PRIORITY1</code>   </td><td class="markdownTableBodyNone">128   </td><td class="markdownTableBodyNone">Priority 1 field    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PTP_CLOCK_PRIORITY2</code>   </td><td class="markdownTableBodyNone">128   </td><td class="markdownTableBodyNone">Priority 2 field    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PTP_BEST_CLOCK_CLASS</code>   </td><td class="markdownTableBodyNone"><code>PTP_CC_DEFAULT</code>   </td><td class="markdownTableBodyNone">Best clock class (PtpClockClass)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PTP_WORST_ACCURACY</code>   </td><td class="markdownTableBodyNone"><code>PTP_CA_PTP_CA_UNKNOWN</code>   </td><td class="markdownTableBodyNone">Worst clock accuracy (PtpClockAccuracy)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PTP_TIME_SOURCE</code>   </td><td class="markdownTableBodyNone"><code>PTP_TSRC_INTERNAL_OSCILLATOR</code>   </td><td class="markdownTableBodyNone">Time source of this device (PtpTimeSource)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md70"></a>
Runtime configuration</h2>
<p>Runtime configuration is done through the <em>Settings interface</em> (<a class="el" href="settings__interface_8h.html" title="This module features functions to tweak around the PTP engine&#39;s almost every property.">settings_interface.h</a>).</p>
<p>Also, the same configuration options are available through the <a class="el" href="cli.html">CLI interface</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
